#' Update local storage
#' 
#' Send the name of the field to update and the value which should be stored
#' in this user's local storage.
#' 
#' @param session The session paramter from the \code{\link{shinyServer}} 
#' function.
#' @param name The name for this setting. This is the name you'll reference
#' later when you want to retrieve this value from your storage object.
#' @param value The value for this setting. Can be a string, in which case it 
#' will be passed through unbothered, or a more complex object which will be
#' translated to JSON.
#' @param encrypt If NULL (the default), the field will not be encrypted. Otherwise,
#' it will expect a PKI public key in the form generated by \code{\link{PKI.load.key}}
#' which will then be used to encrypt the fields.
#' @export
#' @importFrom PKI PKI.encrypt
#' @importFrom RJSONIO toJSON
updateStore <- function(session, name, value, encrypt=NULL){
  if (missing(name) || missing(value) || missing(session)){
    stop("Must provide a name, a value, and a session")
  }
  
  li <- list()
  
  key <- encrypt
  if (is.null(key)){
    # No encryption, just assign.
    li[[name]] <- list(encV=FALSE, data=value)
  } else{
    if (is.null(session$user)){
      # There's no user, so we can't couple our encrypted storage to an identity.
      warning("Encryption requested, but the user is not authenticated. The encryption will be MUCH weaker without binding to a logged-in user.")
    }
    
    # We'll be encrypting the object, then.
    json <- RJSONIO::toJSON(list(data=value, user=session$user))
    
    if (nchar(json) > 215){
      warning("Text to encrypt is longer than 215 bytes, may fail.")
    }
    
    enc <- PKI::PKI.encrypt(charToRaw(json), key)
    char <- paste0(as.character(enc), collapse="")
    
    li[[name]] <- list(encV="1.0", data=char)
  }
  
  session$sendCustomMessage("shinyStore", li)
}
